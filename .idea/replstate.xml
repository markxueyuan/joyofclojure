<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1431365744180">{:repl-history {:ide [], :local [&quot;(def world [[1   1   1   1   1   1   1]\n            [999 999 999 999 999 999 1]\n            [1   1   1   1   1   1   1]\n            [1 999 999 999 999 999 999]\n            [1   1   1   1   1   1   1]\n            [1 999 999 999 999 999 999]\n            [1   1   1   1   1   1   1]])&quot; &quot;(total-cost 1 900 7 0 1)&quot; &quot;(total-cost 1 900 7 1 0)&quot; &quot;(neighbors 7 [0 1])&quot; &quot;(total-cost 2 900 7 1 1)&quot; &quot;(total-cost 2 900 7 0 0)&quot; &quot;(total-cost 2 900 7 0 2)&quot; &quot;(sorted-set [9002 [1 1]] [9002 [0 2]])&quot; &quot;(neighbors 7 [0 2])&quot; &quot;(total-cost 3 900 7 1 2)&quot; &quot;(total-cost 3 900 7 0 1)&quot; &quot;(total-cost 3 900 7 0 3)&quot; &quot;(neighbors 7 [0 3])&quot; &quot;(ns joyofclojure.chapter7-A-star-pathfinding)&quot; &quot;(def world [[1 999] [1 1]])&quot; &quot;(defn neighbors\n  ([size yx]\n    (neighbors [[-1 0] [1 0] [0 -1] [0 1]]\n               size\n               yx))\n  ([deltas size yx]\n    (filter (fn [new-yx]\n              (every? #(&lt; -1 % size) new-yx))\n            (map #(vec (map + yx %))\n                 deltas))))&quot; &quot;(defn estimate-cost [step-cost-est size y x]\n  (* step-cost-est\n     (- (+ size size) y x 2)))&quot; &quot;(defn path-cost [node-cost cheapest-nbr]\n  (+ node-cost\n     (or (:cost cheapest-nbr) 0)))&quot; &quot;(defn total-cost [newcost step-cost-est size y x]\n  (+ newcost\n     (estimate-cost step-cost-est size y x)))&quot; &quot;(defn min-by [f coll]\n  (when (seq coll)\n    (reduce (fn [min other]\n              (if (&gt; (f min) (f other))\n                other\n                min))\n            coll)))&quot; &quot;(defn astar [start-yx step-est cell-costs]\n  (let [size (count cell-costs)]\n    (loop [steps 0\n           routes (vec (repeat size (vec (repeat size nil))))\n           work-todo (sorted-set [0 start-yx])]\n      (if (empty? work-todo)\n        [(peek (peek routes)) :steps steps]\n        (let [[_ yx :as work-item] (first work-todo)\n              rest-work-todo (disj work-todo work-item)\n              nbr-yxs (neighbors size yx)\n              cheapest-nbr (min-by :cost\n                                   (keep #(get-in routes %)\n                                         nbr-yxs))\n              newcost (path-cost (get-in cell-costs yx)\n                                 cheapest-nbr)\n              oldcost (:cost (get-in routes yx))]\n          (if (and oldcost (&gt;= newcost oldcost))\n            (recur (inc steps) routes rest-work-todo)\n            (recur (inc steps) (assoc-in routes yx\n                                         {:cost newcost\n                                          :yxs (conj (:yxs cheapest-nbr [])\n                                                     yx)})\n                   (into rest-work-todo\n                         (map\n                           (fn [w]\n                             (let [[y x] w]\n                               [(total-cost newcost step-est size y x) w]))\n                           nbr-yxs)))))))))&quot; &quot;(neighbors 2 [0 0])&quot; &quot;(total-cost 1 900 2 0 0)&quot; &quot;(total-cost 1 900 2 0 1)&quot; &quot;(total-cost 1 900 2 1 0)&quot; &quot;(neighbors 2 [0 1])&quot; &quot;(total-cost 1000 900 2 1 1)&quot; &quot;(total-cost 1000 900 2 0 0)&quot; &quot;(neighbors 2 [1 0])&quot; &quot;(total-cost 2 900 2 1 1)&quot; &quot;(total-cost 3 900 0 1)&quot; &quot;(total-cost 3 900 2 0 1)&quot; &quot;(total-cost 3 900 2 1 0)&quot; &quot;(total-cost 2 900 2 0 0)&quot; &quot;(defn astar [start-yx step-est cell-costs]\n  (let [size (count cell-costs)]\n    (loop [steps 0\n           routes (vec (repeat size (vec (repeat size nil))))\n           work-todo (sorted-set [0 start-yx])]\n      (if (empty? work-todo)\n        [(peek (peek routes)) :steps steps]\n        (let [[_ yx :as work-item] (first work-todo)\n              rest-work-todo (disj work-todo work-item)\n              nbr-yxs (neighbors size yx)\n              cheapest-nbr (min-by :cost\n                                   (keep #(get-in routes %)\n                                         nbr-yxs))\n              newcost (path-cost (get-in cell-costs yx)\n                                 cheapest-nbr)\n              oldcost (:cost (get-in routes yx))]\n          (println steps)\n          (if (and oldcost (&gt;= newcost oldcost))\n            (recur (inc steps) routes rest-work-todo)\n            (recur (inc steps) (assoc-in routes yx\n                                         {:cost newcost\n                                          :yxs (conj (:yxs cheapest-nbr [])\n                                                     yx)})\n                   (into rest-work-todo\n                         (map\n                           (fn [w]\n                             (let [[y x] w]\n                               [(total-cost newcost step-est size y x) w]))\n                           nbr-yxs)))))))))&quot; &quot;world&quot; &quot;(astar [0 0] 900 world)&quot; &quot;(list + 1 2)&quot; &quot;(eval (list + 1 2))&quot; &quot;(symbol \&quot;+\&quot;)&quot; &quot;(list (symbol \&quot;+\&quot;) 1 2)&quot; &quot;(eval (list (symbol \&quot;+\&quot;) 1 2))&quot; &quot;(defn contexual-eval [ctx expr]\n  (eval\n    `(let [~@(mapcat (fn [[k v]]\n                       [k `'~v])\n                     ctx)]\n       ~expr)))&quot; &quot;'{a 1 b 2}&quot; &quot;(map val {'a 1 'b 2})&quot; &quot;(= 1 '1)&quot; &quot;(identical? 1 1)&quot; &quot;(identical? 1 '1)&quot; &quot;(contextual-eval '{a 1 b (+ 1 2)} '(+ a b))&quot; &quot;3&quot; &quot;(contextual-eval '{a 1 b 3} '(+ a b))&quot; &quot;'{a 1 b (+ 1 2)}&quot; &quot;(concat [1 2] [3 4])&quot; &quot;{'a (+ 1 2) 'b 4}&quot; &quot;'(a (+ 1 2) b 4)&quot; &quot;(contextual-eval '{a 1 b (+ 3 4)} '(+ a b))&quot; &quot;(1 2)&quot; &quot;(eval '(+ 1 2))&quot; &quot;(eval '(+ 1 '(+ 1 2)))&quot; &quot;'(+ 1 '(+ 1 2))&quot; &quot;(defn contextual-eval [ctx expr]\n  (eval\n    `(let [~@(mapcat (fn [[k v]]\n                       [k `'~v])\n                     ctx)]\n       ~expr)))&quot; &quot;(contextual-eval '{a 1 b 2} '(+ a b))&quot; &quot;(defn contextual-eval [ctx expr]\n  (eval\n    `(let [~@(mapcat (fn [[k v]]\n                       [k v])\n                     ctx)]\n       ~expr)))&quot; &quot;(contextual-eval {'b 2} '(- b))&quot; &quot;(ns joyofclojure.chapter8-macro)&quot; &quot;(in-ns 'joyofclojure.chapter8-macro)&quot; &quot;(nnext [1 2 3 4])&quot; &quot;(defmacro do-until [&amp; clauses]\n  (when clauses\n    (list 'clojure.core/when\n          (first clauses)\n          (if (next clauses)\n            (second clauses)\n            (throw (IllegalArgumentException. \&quot;do-util requires an even number of forms\&quot;)))\n          (cons 'do-until (nnext clauses)))))&quot; &quot;(macroexpand-1 '(do-until true (prn 1) false (prn 2)))&quot; &quot;(macroexpand '(do-until true (prn 1) false (prn 2)))&quot; &quot;(walk/macroexpand-all '(do-until true (prn 1) false (prn 2)))&quot; &quot;(do-until true (prn 1) false (prn 2))&quot; &quot;(defmacro unless [condition &amp; body]\n  `(if (not ~condition)\n     (do ~@body)))&quot; &quot;(unless true (println \&quot;nope!\&quot;))&quot; &quot;(unless false (println \&quot;true!\&quot;))&quot; &quot;(var 'x)&quot; &quot;(def x 3)&quot; &quot;(var x)&quot; &quot;x&quot; &quot;(ns joyofclojure.chapter8-macro\n  (:require [clojure.walk :as walk]))&quot; &quot;(defmacro def-watched [name &amp; value]\n  `(do\n     (def ~name ~@value)\n     (add-watch (var ~name)\n                :reload\n                (fn [~'key ~'r old# new#]\n                  (println old# \&quot; -&gt; \&quot; new#)))))&quot; &quot;(def-watched x 3)&quot; &quot;(def x 2)&quot; &quot;(str 'a)&quot; &quot;(declare handle-things)&quot; &quot;(defmacro domain [name &amp; body]\n  `{:tag :domain\n    :attrs {:name (str '~name)}\n    :content [~@(handle-things body)]})&quot; &quot;(defmacro domain [name &amp; body]\n  `{:tag :domain\n    :attrs {:name (str '~name)}\n    :content [~@body]})&quot; &quot;(defmacro grouping [name &amp; body]\n  `{:tag :grouping\n    :attrs {:name (str '~name)}\n    :content [~@(handle-things body)]})&quot; &quot;(declare grok-attrs grok-props)&quot; &quot;(take-while neg? [1 2 -1 0 -1 2])&quot; &quot;(take-while neg? [-1 0 -1 2])&quot; &quot;(drop-while neg? [-1 -2 0 1 -2])&quot; &quot;(drop-while neg? [0 1 -2])&quot; &quot;(defn handle-things [things]\n  (for [t things]\n    {:tag :thing\n     :attrs (grok-attrs (take-while (comp not vector?) t))\n     :content (if-let [c (grok-props (drop-while (comp not vector?) t))]\n                [c]\n                [])}))&quot; &quot;(ns joyofclojure.bibtex-journal\n  (:require [clojure.string :as string]))&quot; &quot;(slurp \&quot;D:/data/MyCollection.bib\&quot;)&quot; &quot;(ns joyofclojure.bibtex-journal\n  (:require [clojure.string :as string])\n  (:import (java.io File))\n  (:import (org.jbibtex BibTeXDatabase\n                        BibTeXEntry\n                        BibTeXFormatter\n                        BibTeXParser\n                        BibTeXString\n                        Key\n                        ParseException)))&quot; &quot;(.parseBibTeX (File. \&quot;D:/data/MyCollection.bib\&quot;))&quot; &quot;(BibTeXParser/parseBibTeX (File. \&quot;D:/data/MyCollection.bib\&quot;))&quot; &quot;(BibTeXDataBase/parseBibTeX (File. \&quot;D:/data/MyCollection.bib\&quot;))&quot; &quot;BibTexDatabase&quot;], :remote []}}</component>
</project>